// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
static _SSAstmt: std::option::Option<SSAstmt> = {
    let mut _0: std::option::Option<SSAstmt>;

    bb0: {
        _0 = std::option::Option::<SSAstmt>::None;
        return;
    }
}

static _ESSAstmt: std::option::Option<ESSAstmt> = {
    let mut _0: std::option::Option<ESSAstmt>;

    bb0: {
        _0 = std::option::Option::<ESSAstmt>::None;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: std::boxed::Box<[u8; 3]>;
    let mut _2: [u8; 3];
    let mut _4: *mut [u8; 3];
    let mut _5: &mut std::boxed::Box<[u8; 3]>;
    let _7: &[u8];
    let mut _8: std::ops::Range<usize>;
    let mut _9: std::ops::Range<usize>;
    let mut _11: std::option::Option<usize>;
    let mut _12: &mut std::ops::Range<usize>;
    let mut _13: isize;
    let mut _16: usize;
    let mut _17: bool;
    let mut _19: *const u8;
    scope 1 {
        debug data => _1;
        let _3: *const u8;
        scope 2 {
            debug ptr => _3;
            let _6: usize;
            scope 3 {
                debug len => _6;
                scope 4 {
                    debug s1_slice => _7;
                    let mut _10: std::ops::Range<usize>;
                    scope 5 {
                        debug iter => _10;
                        let _14: usize;
                        scope 6 {
                            debug i => _14;
                            let _15: u8;
                            scope 7 {
                                debug val1 => _15;
                                let _18: u8;
                                scope 8 {
                                    debug val2 => _18;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = [const 10_u8, const 20_u8, const 30_u8];
        _1 = std::boxed::Box::<[u8; 3]>::new(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _1;
        _4 = std::boxed::Box::<[u8; 3]>::as_mut_ptr(copy _5) -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _3 = move _4 as *const u8 (PtrToPtr);
        _6 = const 3_usize;
        _7 = std::slice::from_raw_parts::<'_, u8>(copy _3, copy _6) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _9 = std::ops::Range::<usize> { start: const 0_usize, end: copy _6 };
        _8 = <std::ops::Range<usize> as std::iter::IntoIterator>::into_iter(move _9) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _10 = move _8;
        goto -> bb5;
    }

    bb5: {
        _12 = &mut _10;
        _11 = <std::ops::Range<usize> as std::iter::Iterator>::next(copy _12) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb9, 1: bb8, otherwise: bb7];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _14 = copy ((_11 as Some).0: usize);
        _16 = Len((*_7));
        _17 = Lt(copy _14, copy _16);
        assert(move _17, "index out of bounds: the length is {} but the index is {}", move _16, copy _14) -> [success: bb10, unwind: bb13];
    }

    bb9: {
        drop(_1) -> [return: bb12, unwind continue];
    }

    bb10: {
        _15 = copy (*_7)[_14];
        _19 = std::ptr::const_ptr::<impl *const u8>::add(copy _3, copy _14) -> [return: bb11, unwind: bb13];
    }

    bb11: {
        _18 = copy (*_19);
        goto -> bb5;
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_1) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}
